GRAMMAR
PEG


#MEANS terminals???
we have : #eof
          #binop
          #unop
      

Operator Type          Precedence Description
’ ’      primary       5          Literal string
" "      primary       5          Literal string
[ ]      primary       5          Character class
.        primary       5          Any character
(e)      primary       5          Grouping
e?       unary suffix  4          Optional
e*       unary suffix  4          Zero-or-more
e+       unary suffix  4          One-or-more
&e       unary prefix  3          And-predicate
!e       unary prefix  3          Not-predicate
e1 e2    binary        2          Sequence
e1 / e2  binary        1          Prioritized Choice


CFG rules ( Contex Free Grammer)


Here is the grammar of the language.

stmt <- kdefs * #eof
* IS UNARY SUFFIX  -> MEANS ZERO OR MORE 

kdefs <- 'def ' defs ';'  // string "def " followed by defs(rule) , followed by ";"

| expressions ';'


// | MEANS Prioritized Choice    

defs <- prototype expressions


// .  primaryOp  Any Character
prototype <- (
                'unary ' . decimal_const?
                | 'binary ' . decimal_const?
            )
            identifier
            prototype_args

prototype_args <- '(' ( identifier ':' type )* ')' ':' type

type <- 'int ' | 'double ' | 'void '

expressions <- for_expr
                | if_expr
                | while_expr
                | expression (':' expression )*


for_expr <- 'for ' identifier '=' expression ','
                identifier '<' expression ','
                expression 'in ' expressions

if_expr <- 'if ' expression 'then ' expressions ('else ' expressions )?

while_expr <- 'while ' expression 'do ' expressions

expression <- unary (#binop ( unary | expression ) )*

unary <- #unop unary | postfix

postfix <- primary call_expr?

call_expr <- '(' ( expression (',' expression )*) ? ')'

primary <- identifier
| literal
| '(' expressions ')


identifier <- [a - zA - Z ][ a - zA - Z0 -9]*

// The parsing expression foo !(bar) 
// matches the text "foo" but only if it is not 
//followed by the text "bar".

dot <- '.' !'.'


decimal_const <- [0 -9]+


double_const <- ( decimal_const dot [0 -9]* | dot [0 -9]+ )

//UNARY SUFFIX + MEANS ONE OR MORE

literal <- decimal_const
| double_const